#include "itkMultiResolutionImageRegistrationMethod.h"
#include "itkMattesMutualInformationImageToImageMetric.h"
#include "../../../Metrics/MANGFImageToImageMetric/Code/itkNormalizedGradientFieldImageToImageMetric.h"
#include "../../../Metrics/MANGFImageToImageMetric/Code/itkNGFMetricKernel.h"
#include "../../../Metrics/MANGFImageToImageMetric/itkMANGF.h"
#include "../../../Metrics/MANGF2ImageToImageMetric/itkMANGF2.h"
#include "../../../Metrics/MANGFMSEImageToImageMetric/itkMANGFMSE.h"
#include "itkCastImageFilter.h"
#include "itkBSplineTransform.h"
#include "itkResampleImageFilter.h"
#include "itkLinearInterpolateImageFunction.h"
#include "itkLBFGSOptimizer.h"
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"


#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"
#include "itkImageMaskSpatialObject.h"
#include "itkTransformToDeformationFieldSource.h"

#include "itkVersion.h"
#include "itkTransformFileWriter.h"
#include "itkTransformFileReader.h"

#include <iostream>
#include <algorithm> // for copy
#include <iterator> // for ostream_iterator
#include <vector>
#include<fstream>
#include<sstream>
#include<iostream>
#include "../../Version.h"



#include "itkVersion.h"
#include "itkTransformFileWriter.h"
#include "itkTransformFileReader.h"





const    unsigned int    Dimension = 3;


typedef  short  PixelType;


	typedef itk::Image< PixelType, Dimension >  FixedImageType;
	typedef itk::Image< PixelType, Dimension >  MovingImageType;
	typedef   float                                    InternalPixelType;
	typedef itk::Image< InternalPixelType, Dimension > InternalImageType;


	typedef itk::LinearInterpolateImageFunction<
			InternalImageType,
			double             > InterpolatorType;

//read
	typedef itk::ImageFileReader< FixedImageType  > FixedImageReaderType;
	typedef itk::ImageFileReader< MovingImageType > MovingImageReaderType;
	typedef itk::CastImageFilter<
				FixedImageType, InternalImageType > FixedCastFilterType;
		typedef itk::CastImageFilter<
				MovingImageType, InternalImageType > MovingCastFilterType;



	typedef itk::MultiResolutionImageRegistrationMethod<
			InternalImageType,
			InternalImageType >   RegistrationType;

	typedef itk::MultiResolutionPyramidImageFilter<
			InternalImageType,
			InternalImageType >   FixedImagePyramidType;
	typedef itk::MultiResolutionPyramidImageFilter<
			InternalImageType,
			InternalImageType >   MovingImagePyramidType;

	const unsigned int SpaceDimension = Dimension;
	const unsigned int SplineOrder = 3;
	typedef double CoordinateRepType;

#if ITK_VERSION_MAJOR < 4
typedef itk::BSplineDeformableTransform<
		CoordinateRepType,
		SpaceDimension,
		SplineOrder >     TransformType;
#else
typedef itk::BSplineTransform<
		CoordinateRepType,
		SpaceDimension,
		SplineOrder >     TransformType;
#endif
typedef itk::LBFGSOptimizer       OptimizerType;

//output
typedef itk::ResampleImageFilter<
			InternalImageType,
			FixedImageType >    ResampleFilterType;

typedef unsigned char OutputPixelType;
typedef itk::Image< PixelType, Dimension >  OutputImageType;

typedef itk::CastImageFilter<FixedImageType,
		OutputImageType > CastFilterType;

typedef itk::ImageFileWriter< OutputImageType >  WriterType;


typedef itk::Vector< float,  Dimension >  VectorType;
				typedef itk::Image< VectorType,  Dimension >   OutputTransformationImageType;


#include "../../../include/funzioniIO.h"
#include "../../../include/funzioniREC.h"



int main( int argc, char *argv[] )
{



	std::vector<std::string>Vparams;
	Vparams.push_back("program name");
	int T=1;Vparams.push_back("fixedImageFile");
	int S=2;Vparams.push_back("movingImageFile");
	int O=3;Vparams.push_back("output Image");
	int OVF=4;Vparams.push_back("VF out");
	int MMODE=5; int mmode=0;Vparams.push_back(	availableMetrics()); readParametersFromStdin(&mmode,MMODE,argv,argc,no);
	int BIN=MMODE+1; int NB=50;Vparams.push_back("Mattes number of bins");readParametersFromStdin(&NB,BIN,argv,argc,no);
	int MAPERCENTAGE=BIN+1; double nPCTMA=0.1; Vparams.push_back("Mattes percecntage");readParametersFromStdin(&nPCTMA,MAPERCENTAGE,argv,argc,no);
	int LAMBDA=MAPERCENTAGE+1; double lambda=1.0;Vparams.push_back("lambda values MI + lambda NGF");readParametersFromStdin(&lambda,LAMBDA,argv,argc,no);
	int LAMBDADERIVATIVE=LAMBDA+1;double lambdaderivative=1e-4;Vparams.push_back("Lambda derivatuive ");readParametersFromStdin(&lambdaderivative,LAMBDADERIVATIVE,argv,argc,no);
	int ETAF=LAMBDADERIVATIVE+1;double etaF=2; Vparams.push_back("Eta values Reference (NGF noise)");readParametersFromStdin(&etaF,ETAF,argv,argc,no);
	int ETAM=ETAF+1;	double etaM=2; Vparams.push_back("Eta values Source (NGF noise)");readParametersFromStdin(&etaM,ETAM,argv,argc,no);
	int NGFEV=ETAM+1; int NGFEvaluator=0;Vparams.push_back("NGF Evaluator (0 scalar,1cross,2scdelta,3Delta,4Delta2)");readParametersFromStdin(&NGFEvaluator,NGFEV,argv,argc,no);
	int MU=NGFEV+1; double mu=0.1;Vparams.push_back("Tau MSE"); readParametersFromStdin(&mu,MU,argv,argc,no);
	int MUDERIVATIVES=MU+1; double muderivatives=0.1;Vparams.push_back("Tau Derivative MSE ");readParametersFromStdin(&muderivatives,MUDERIVATIVES,argv,argc,no);
	int NL=MUDERIVATIVES+1; 	int numberOfLevels=1; Vparams.push_back("Levels");readParametersFromStdin(&numberOfLevels,NL,argv,argc,no);
	int NG=NL+1; int ng =5;  Vparams.push_back("Number of grid ndes per axes");readParametersFromStdin(&ng,NG,argv,argc,no);
	int NI=NG+1; 	int ni=200; Vparams.push_back("Max number of Iterations");readParametersFromStdin(&ni,NI,argv,argc,no);
	int OSL=NI+1; double osl=1.0; Vparams.push_back("optimizer step length (positive real number which determines the step size in the line search");readParametersFromStdin(&osl,OSL,argv,argc,no);
	int OLSA=OSL+1; double olsa=0.9; Vparams.push_back("oprimizer Line search accuracy (If the function and gradient evalutions are inexpensive with respect to the cost of the iterations it may be advantageous to set the value to a small value (say 0.1)"")");readParametersFromStdin(&olsa,OLSA,argv,argc,no);
	int OGCT=OLSA+1; double ogct=0.9; Vparams.push_back("gradient convergence tolerance (positive real number that determines the accuracy with which the solution is to be found. The optimization terminates when: ||G|| < gtol max(1,||X||) where ||.|| denotes the Euclidean norm.");readParametersFromStdin(&ogct,OGCT,argv,argc,no);
	int FMASK=OGCT+1;Vparams.push_back("Mask Reference");
	int MMASK=FMASK+1; Vparams.push_back("Mask source");
	int NT=MMASK+1; 	int nt=2; Vparams.push_back("Number of thread");readParametersFromStdin(&nt,NT,argv,argc,no);
	int TIN=NT+1; Vparams.push_back("transformin.txt");
	int TOUT=TIN+1; Vparams.push_back("transforout.txt");

	if( argc < 4 )
	{
		std::cout<<argv[0]<<" ";
		printVersion();
		printParam(Vparams);
		std::cout << "Skip feature\t"<<no<< std::endl;
		std::cout << "Output and input type unsigned char \t"<< std::endl;


		firma();
		return EXIT_FAILURE;
	}

	TransformType::Pointer      transform     = TransformType::New();
	OptimizerType::Pointer      optimizer     = OptimizerType::New();
	InterpolatorType::Pointer   interpolator  = InterpolatorType::New();
	RegistrationType::Pointer   registration  = RegistrationType::New();

	FixedImagePyramidType::Pointer fixedImagePyramid =
			FixedImagePyramidType::New();
	MovingImagePyramidType::Pointer movingImagePyramid =
			MovingImagePyramidType::New();

	registration->SetOptimizer(     optimizer     );
	registration->SetTransform(     transform     );
	registration->SetInterpolator(  interpolator  );

	registration->SetFixedImagePyramid( fixedImagePyramid );
	registration->SetMovingImagePyramid( movingImagePyramid );
	registration->SetNumberOfThreads(nt);

	fixedImagePyramid->SetNumberOfThreads(nt);
	movingImagePyramid->SetNumberOfThreads(nt);


	FixedImageReaderType::Pointer  fixedImageReader  = FixedImageReaderType::New();
	MovingImageReaderType::Pointer movingImageReader = MovingImageReaderType::New();

	fixedImageReader->SetFileName(  argv[T] );
	movingImageReader->SetFileName( argv[S] );




	FixedCastFilterType::Pointer fixedCaster   = FixedCastFilterType::New();
	MovingCastFilterType::Pointer movingCaster = MovingCastFilterType::New();
	fixedCaster->SetNumberOfThreads(nt);
	movingCaster->SetNumberOfThreads(nt);

	fixedCaster->SetInput(  fixedImageReader->GetOutput() );
	movingCaster->SetInput( movingImageReader->GetOutput() );

	registration->SetFixedImage(    fixedCaster->GetOutput()    );
	registration->SetMovingImage(   movingCaster->GetOutput()   );


	fixedCaster->Update();

	registration->SetFixedImageRegion(
			fixedCaster->GetOutput()->GetBufferedRegion() );

	typedef RegistrationType::ParametersType ParametersType;
	ParametersType initialParameters( transform->GetNumberOfParameters() );



//intializeit!!
	if (argc>TIN)
			if(*argv[TIN]!=no){

#if (ITK_VERSION_MAJOR == 4 && ITK_VERSION_MINOR >= 5) || ITK_VERSION_MAJOR > 4
  itk::TransformFileReaderTemplate<double>::Pointer reader =
    itk::TransformFileReaderTemplate<double>::New();
#else
  itk::TransformFileReader::Pointer reader = itk::TransformFileReader::New();
#endif


  reader->SetFileName(argv[TIN]);
  reader->Update();
  initialParameters= reader->GetTransformList()->begin()->GetPointer()->GetParameters();
std::cout<<"intial transform: " << initialParameters <<"\n";
			} else {
									transform->SetIdentity();

	initialParameters= transform->GetParameters();

			};

	registration->SetInitialTransformParameters( initialParameters );


	InternalImageType::RegionType fixedRegion = registration->GetFixedImage()->GetBufferedRegion();
	registration->SetFixedImageRegion( fixedRegion );


	//  The reader should note that the BSpline computation requires a
	//  finite support region ( 1 grid node at the lower borders and 2
	//  grid nodes at upper borders). place the grid origin such that
	//  grid node (1,1) coincides with the first pixel in the fixed image.


	TransformType::PhysicalDimensionsType   fixedPhysicalDimensions;
	TransformType::MeshSizeType             meshSize;
	for( unsigned int i=0; i < Dimension; i++ )
	{
		fixedPhysicalDimensions[i] = registration->GetFixedImage()->GetSpacing()[i] *
				static_cast<double>(
						registration->GetFixedImage()->GetLargestPossibleRegion().GetSize()[i] - 1 );
	}
	unsigned int numberOfGridNodesInOneDimension = ng;
	meshSize.Fill( numberOfGridNodesInOneDimension - SplineOrder );
	transform->SetTransformDomainOrigin( registration->GetFixedImage()->GetOrigin() );
	transform->SetTransformDomainPhysicalDimensions( fixedPhysicalDimensions );
	transform->SetTransformDomainMeshSize( meshSize );
	transform->SetTransformDomainDirection( registration->GetFixedImage()->GetDirection() );

	typedef TransformType::ParametersType     ParametersType;

	const unsigned int numberOfParameters =
			transform->GetNumberOfParameters();

	//ParametersType parameters( numberOfParameters );

	//parameters.Fill( 0.0 );

	//transform->SetParameters( parameters );

	//  We now pass the parameters of the current transform as the initial
	//  parameters to be used when the registration process starts.

	//registration->SetInitialTransformParameters( transform->GetParameters() );


	//  Next we set the parameters of the LBFGS Optimizer.

	optimizer->SetGradientConvergenceTolerance( ogct );
	optimizer->SetLineSearchAccuracy( olsa);
	optimizer->SetDefaultStepLength( osl );
	optimizer->TraceOn();
	optimizer->SetMaximumNumberOfFunctionEvaluations( ni );
	optimizer->SetMinimize(1);






	const unsigned int numberOfPixels = fixedImageReader->GetOutput()->GetLargestPossibleRegion().GetNumberOfPixels();
		const unsigned int numberOfSamplesMA =static_cast< unsigned int >( numberOfPixels * nPCTMA);
	///////

		//parameter metric to print
		std::vector<std::string> PMETRIC;
		std::vector<std::string> VMETRIC;


	qualemetrica(registration, mmode,NB, numberOfSamplesMA,
			lambda, lambdaderivative, etaF,
			etaM, NGFEvaluator, mu, muderivatives,
			nt,PMETRIC,VMETRIC);

	pMetric("metric",PMETRIC,VMETRIC);
	//MASCHERE
	maschere(registration,FMASK,MMASK, argc, argv,no);


	std::vector<std::string> PR;
	std::vector<std::string> VR;

	registration->SetNumberOfLevels(numberOfLevels);PR.push_back("Registration number of levels ");VR.push_back(tostr(registration->GetNumberOfLevels()));
	pMetric("registration",PR,VR);


	std::cout << std::endl << "Starting Registration" << std::endl;

	try
	{
		registration->Update();
		std::cout << "Optimizer stop condition = "
				<< registration->GetOptimizer()->GetStopConditionDescription()
				<< std::endl;
	}
	catch( itk::ExceptionObject & err )
	{
		std::cerr << "ExceptionObject caught !" << std::endl;
		std::cerr << err << std::endl;
		return EXIT_FAILURE;
	}
	OptimizerType::ParametersType finalParameters =
			registration->GetLastTransformParameters();




	// Software Guide : BeginCodeSnippet
	transform->SetParameters( finalParameters );
	// Software Guide : EndCodeSnippet




	transformedImageWrite(registration,transform,O,nt,argc,argv);
	transformationWrite(registration,OVF,argc,argv,no);



	return EXIT_SUCCESS;
}








